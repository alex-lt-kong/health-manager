#!/usr/bin/python3

from flask import Flask, render_template, Response, request, redirect, url_for
from flask_cors import CORS
from flask import request
from waitress import serve

import argparse
import datetime
import json
import logging
import math
import os
import pymysql
import re
import signal
import smtplib
import socket
import subprocess
import sys
import threading
import time

app = Flask(__name__)

CORS(app) # This necessary for javascript to access a telemetry link without opening it: https://stackoverflow.com/questions/22181384/javascript-no-access-control-allow-origin-header-is-present-on-the-requested
stop_signal = False
settings_path = '/root/bin/weight-manager/settings.json'

db_url = 'localhost'
db_username = 'biological_data'
db_password = 'aPdji21fjiI'
db_name = 'biological_data'

def get_average_weight(subject_name: str, days: int):

   # days -= 1
    
    conn = pymysql.connect(db_url, db_username, db_password, db_name)
    cursor = conn.cursor()
    sql = 'SELECT `id`, `record_time`, `value` FROM `weights` WHERE (`record_time` between (NOW() - INTERVAL %s DAY ) and NOW()) AND `subject_name` = %s'
    cursor.execute(sql, (days, subject_name))
    results = cursor.fetchall()
    entry_count = 0
    total_weight = 0
    for result in results:
        total_weight += result[2]
        entry_count += 1
    
    if entry_count > 0:
        average_weight = round(total_weight / entry_count, 2)
    else:
        average_weight = 0

    return entry_count, average_weight
    
def get_today_weight(subject_name: str):
    
    conn = pymysql.connect(db_url, db_username, db_password, db_name)
    cursor = conn.cursor()
    sql = 'SELECT `id`, `record_time`, `value` FROM `weights` WHERE `record_time` >= CURDATE() AND `subject_name` = %s ORDER BY record_time DESC LIMIT 1'
    cursor.execute(sql, (subject_name))
    results = cursor.fetchall()
    
    if len(results) == 1:
        today_weight = float(results[0][2])
    elif len(results) == 0:
        today_weight = 0
    else:
        today_weight = -1
        
    return today_weight
    
    
@app.route('/', methods=['GET'])
def index():
    
    subject_name = None
    
    if 'subject_name' in request.args:
        subject_name = request.args.get('subject_name')
    if subject_name == None or len(subject_name) <= 0:
        return '未指定参数subject_name'

    if 'weight_today' in request.args:

        try:
            weight_today = float(request.args.get('weight_today'))
        except:
            return('输入的不是数字！请重新输入！（注意检查中英文标点）')   
        current_time = datetime.datetime.now().replace(microsecond=0, second=0, minute=0)
        conn = pymysql.connect(db_url, db_username, db_password, db_name)
        conn.autocommit(True) # It appears that both UPDATE and SELECT need "commit"
        cursor = conn.cursor()
        sql = 'SELECT `id`, `record_time`, `value` FROM `weights` WHERE `record_time` = %s AND `subject_name` = %s'
        cursor.execute(sql, (current_time, subject_name))
        results = cursor.fetchall()
        if len(results) > 0:
            sql = 'UPDATE `weights` SET `value` = %s WHERE `record_time` = %s AND `subject_name` = %s'
            cursor.execute(sql, (weight_today, current_time, subject_name))
        else:
            sql = 'INSERT INTO `weights` (`record_time`, `subject_name`, `value`) VALUES (%s, %s, %s)'
            cursor.execute(sql, (current_time, subject_name, weight_today))
        cursor.close()
        
        url = 'monitor.sz.lan/weight_manager/show/?subject_name={}'.format(subject_name)

        return redirect('https://{}'.format(url))

            
    return render_template('record.html', 
                        subject_name = subject_name)
    
@app.route('/show/', methods=['GET'])
def show():
    
    subject_name = ''
    if 'subject_name' in request.args:
        subject_name = request.args.get('subject_name')
    
  #  print(subject_name)
    
    today_weight = get_today_weight(subject_name)
    today_date = datetime.datetime.now().strftime("%Y年%m月%d日")
    
    weight_data = []
    
    denominators = [1, 7, 14, 30, 90, 182, 365, 730]
    denominators_names = ['昨日', '1周', '2周', '1月', '3月', '半年', '1年', '2年']
    
    for i in range(len(denominators)):
        entry_count, average_weight = get_average_weight(subject_name, denominators[i])

        if average_weight != 0:
            change = (today_weight - average_weight) * 1000 / average_weight
            if change > 0:
                change_html = '<span class="w3-text-red">{:+.0f}‰</span>'.format(change)
            elif change < 0:
                change_html = '<span class="w3-text-green">{:+.0f}‰</span>'.format(change)
            else:
                change_html = '0‰'
        else:
            change_html = '0‰'
        attendance_rate = '{:.0f}%'.format(entry_count * 100 / denominators[i])
        average_weight = '{:.1f}'.format(average_weight)
        weight_data.append([denominators_names[i], entry_count, attendance_rate, average_weight, change_html])
    
    
    return render_template('show.html', 
                            subject_name = subject_name, 
                            today_weight = today_weight, 
                            today_date = today_date, 
                            weight_data = weight_data)
  #  return(html_text)
  
@app.route('/chart/', methods=['GET'])
def chart():

    subject_name = ''
    days = -1
    if 'subject_name' in request.args:
        subject_name = request.args.get('subject_name')
    
    
    try:    
        days = int(request.args.get('days')) - 1
    except:
        pass
    if days <= 0 or days >=3650:
        days = 30
    
    conn = pymysql.connect(db_url, db_username, db_password, db_name)
    conn.autocommit(True) # It appears that both UPDATE and SELECT need "commit"
    cursor = conn.cursor()
    
    sql = 'SELECT `record_time`, `value` FROM `weights` WHERE `subject_name` = %s AND (`record_time` >= (DATE(NOW()) - INTERVAL %s DAY)) ORDER BY `record_time` DESC'
    cursor.execute(sql, (subject_name, days))
    weight_data = cursor.fetchall()    
    readings_strings = []
    readings_strings.append('')
    times_string = ''
    for weight_entry in weight_data:
        readings_strings[0] += str(weight_entry[1]) + ', '
        times_string += '"' + str(weight_entry[0]) + '", '
    readings_strings[0] = readings_strings[0][:-2]
    times_string = times_string[:-2]

    return render_template('chart.html', 
                            times_string = times_string, 
                            readings_strings = readings_strings, 
                            chart_width = 100, 
                            sampling_points = ['weight'], 
                            sampling_points_cn = ['体重[{}]'.format(subject_name)], 
                            readings_unit = 'KG', 
                            available_sampling_points_string = '', 
                            available_data_types_string = '', 
                            oldest_time_string = '',
                            legend_display = 'false')
                               
def cleanup(*args):
    
    global stop_signal
    stop_signal = True
    logging.info('Stop signal received, exiting')       
    sys.exit(0)
    
def send_notification_email(delay: int, from_name: str, subject: str, mainbody: str):
        
    global stop_signal

    logging.info('Wait for {} seconds before sending the email'.format(delay))
    sec_count = 0
    while sec_count < delay:
        time.sleep(1)  # This delay has to be long enough to accommodate the startup time of pfSense.
        sec_count += 1
        if stop_signal:
            return
    logging.debug('Sending [{}] notification email'.format(subject))
    
    try:
        with open(settings_path, 'r') as json_file:
            json_str = json_file.read()
            json_data = json.loads(json_str)
    except:
        json_data = None
        logging.error(sys.exc_info())
    
    sender = json_data['email']['address']
    password = json_data['email']['password']
    receivers = ['admin@mamsds.net']

    message = ('From: {} <{}>\n'
                'To: Mamsds Admin Account <admin@mamsds.net>\n'
                'Content-Type: text/html; charset="UTF-8"\n'
                'Subject: {}\n'
                '<meta http-equiv="Content-Type"  content="text/html charset=UTF-8" /><html><font size="2" color="black">{}</font></html>'.format(from_name, sender, subject, mainbody.replace('\n', '<br>')))

    try:
        smtpObj = smtplib.SMTP(host='server172.web-hosting.com', port=587)
        smtpObj.starttls()
        smtpObj.login(sender, password)
        smtpObj.sendmail(sender, receivers, message.encode('utf-8'))
        smtpObj.quit()
        logging.debug("Email [{}] sent successfully".format(subject))
    except:
        logging.error("{}".format(sys.exc_info()))

def main():
    
    ap = argparse.ArgumentParser()
    ap.add_argument('--debug', dest='debug', action='store_true')
    args = vars(ap.parse_args())
    debug_mode = args['debug']

    logging.basicConfig(
        filename='/var/log/mamsds/weight-manager.log',
        level=logging.DEBUG if debug_mode else logging.INFO,
        format='%(asctime)s.%(msecs)03d %(levelname)s %(module)s - %(funcName)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
    )
    logging.info('weight manager started') 
    start_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    if debug_mode == True:
        print('Running in debug mode')
        logging.info('Running in debug mode')
    else:
        logging.info('Running in production mode')

    signal.signal(signal.SIGINT, cleanup)
    signal.signal(signal.SIGTERM, cleanup) 
    email_sender = threading.Thread(target=send_notification_email, args=(0 if debug_mode else 600, 'weight manager notification service', 'weight manager started', 'weight manager is started at {}'.format(start_time)))
    email_sender.start()
    logging.info('weight manager server')
    
#    app.run('localhost', 90)
    serve(app, host="0.0.0.0", port=90)
    
if __name__ == '__main__':
    
    main()

