#!/usr/bin/python3

from flask import Flask, render_template, Response, request, redirect, session, url_for
from flask_cors import CORS
from scipy.stats import norm
from statsmodels.tsa.stattools import coint, adfuller
from sqlalchemy import create_engine, text
from waitress import serve

import argparse
import datetime as dt
import hashlib
import json
import logging
import matplotlib
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt
import mpld3
import numpy as np
import pandas as pd
import pymysql
import scipy.stats as stats
import signal
import smtplib
import statsmodels.api as sm
import sys
import threading
import time


app = Flask(__name__)
app.secret_key = b'jkjk*&(*&98wqoe"]/e;.fdloefkiue78u9io1'
app.config.update(
    SESSION_COOKIE_SECURE=True,
    SESSION_COOKIE_HTTPONLY=True,
    # If this is set to True, client-side JavaScript will not be able to
    # access the session cookie.
    SESSION_COOKIE_SAMESITE='Lax',
)


CORS(app)
# This necessary for javascript to access a telemetry link without opening it:
# https://stackoverflow.com/questions/22181384/javascript-no-access-control-allow-origin-header-is-present-on-the-requested
stop_signal = False
settings_path = '/root/bin/weight-manager/settings.json'
users_path = '/root/bin/weight-manager/users.json'
app_name = 'weight_manager'
relative_url = f'../{app_name}'

db_url = 'localhost'
db_username = 'biological_data'
db_password = 'aPdji21fjiI'
db_name = 'biological_data'


def get_average_weight(username: str, days: int):

    conn = pymysql.connect(db_url, db_username, db_password, db_name)
    cursor = conn.cursor()
    sql = '''
    SELECT COUNT(`value`), AVG(`value`)
    FROM `weights`
    WHERE (`record_time` between (NOW() - INTERVAL %s DAY ) and NOW()) AND
         `username` = %s'''
    cursor.execute(sql, (days, username))
    results = cursor.fetchall()

    if results is not None:
        entry_count = results[0][0]
    else:
        entry_count = 0
    if entry_count > 0:
        average_weight = results[0][1]
    else:
        average_weight = np.nan

    return entry_count, average_weight


def get_today_weight(username: str):

    conn = pymysql.connect(db_url, db_username, db_password, db_name)
    cursor = conn.cursor()
    sql = '''
    SELECT `id`, `record_time`, `value`, `remark`
    FROM `weights`
    WHERE `record_time` >= CURDATE() AND `username` = %s
    ORDER BY record_time DESC LIMIT 1'''
    cursor.execute(sql, (username))
    results = cursor.fetchall()

    if len(results) == 1:
        today_weight = float(results[0][2])
        latest_record_time = results[0][1]
        remark = str(results[0][3])
    else:
        today_weight = np.nan
        latest_record_time = None
        remark = None

    return today_weight, latest_record_time, remark


@app.route('/logout/')
def logout():

    if f'{app_name}' in session:
        session[f'{app_name}'].pop('username', None)
    return redirect(f'{relative_url}/')


@app.before_request
def make_session_permanent():
    session.permanent = True
    app.permanent_session_lifetime = dt.timedelta(days=365)

@app.route('/login/', methods=['GET', 'POST'])
def login():

    if f'{app_name}' in session and 'username' in session[f'{app_name}']:
        return redirect(f'{relative_url}/')

    if request.method == 'POST':
        try:
            with open(users_path, 'r') as json_file:
                json_str = json_file.read()
                json_data = json.loads(json_str)
        except Exception as e:
            return render_template('login.html',
                        message = f'<span style="color:red">错误：{e}</span>')
        if request.form['username'] not in json_data['users']:
            return render_template('login.html',
                                   message = '<span style="color:red">错误：用户{}不存在</span>'.format(request.form['username']))
        if (hashlib.sha256(request.form['password'].encode('utf-8')).hexdigest()
              != json_data['users'][request.form['username']]):
            return render_template('login.html',
                                   message='<span style="color:red">错误：密码错误</span>')

        session[f'{app_name}'] = {}
        session[f'{app_name}']['username'] = request.form['username']

        return redirect(f'{relative_url}/')

    return render_template('login.html', message = '')


@app.route('/', methods=['GET'])
def index():

    if f'{app_name}' in session and 'username' in session[f'{app_name}']:
        username = session[f'{app_name}']['username']
    else:
        return redirect(f'{relative_url}/login/')

    if 'weight_today' not in request.args:
        return render_template('record.html', username = username)

    try:
        weight_today = float(request.args.get('weight_today'))
        remark = request.args.get('remark')
    except:
        return('输入的不是数字！请重新输入！（注意检查中英文标点）')

    current_time = dt.datetime.now()
    if current_time.minute < 30:
        current_time = current_time.replace(microsecond=0, second=0, minute=0)
    else:
        current_time = current_time.replace(microsecond=0, second=0, minute=30)

    conn = pymysql.connect(db_url, db_username, db_password, db_name)
    conn.autocommit(True) # It appears that both UPDATE and SELECT need "commit"
    cursor = conn.cursor()
    sql = 'SELECT `id`, `record_time`, `value` FROM `weights` WHERE `record_time` = %s AND `username` = %s'
    cursor.execute(sql, (current_time, username))
    results = cursor.fetchall()
    if len(results) > 0:
        sql = 'UPDATE `weights` SET `value` = %s, `remark` = %s WHERE `record_time` = %s AND `username` = %s'
        cursor.execute(sql, (weight_today, remark, current_time, username))
    else:
        sql = 'INSERT INTO `weights` (`record_time`, `username`, `value`, `remark`) VALUES (%s, %s, %s, %s)'
        cursor.execute(sql, (current_time, username, weight_today, remark))
    cursor.close()

    return redirect(f'{relative_url}/summary/')


@app.route('/summary/', methods=['GET'])
def summary():

    if f'{app_name}' in session and 'username' in session[f'{app_name}']:
        username = session[f'{app_name}']['username']
    else:
        return redirect(f'{relative_url}/login/')

    today_weight, latest_record_time, remark = get_today_weight(username)

    if latest_record_time is None:
        latest_record_time = dt.datetime.now().strftime('%Y-%m-%d %H:%M')
    else:
        latest_record_time = latest_record_time.strftime('%Y-%m-%d %H:%M')

    weight_data = []

    denominators = [3, 14, 60, 182, 365, 730]
    denominators_names = ['3日', '2周', '2月', '6月', '1年', '2年']

    for i in range(len(denominators)):
        entry_count, average_weight = get_average_weight(username, denominators[i])

        if average_weight != 0:
            change = (today_weight - average_weight) * 1000 / average_weight
            if change > 0:
                change_html = '<span class="w3-text-red">{:+.0f}‰</span>'.format(change)
            elif change < 0:
                change_html = '<span class="w3-text-green">{:+.0f}‰</span>'.format(change)
            elif change == 0:
                change_html = '0‰'
            else:
                change_html = 'nan‰'
        else:
            change_html = 'nan‰'
        attendance_rate = '{:.0f}%'.format(entry_count * 100 / denominators[i])
        average_weight = '{:.1f}'.format(average_weight)
        weight_data.append([denominators_names[i], entry_count, attendance_rate, average_weight, change_html])

    return render_template('summary.html',
                           username=username,
                           today_weight=today_weight,
                           remark=remark,
                           latest_record_time=latest_record_time,
                           weight_data=weight_data)


@app.route('/chart/', methods=['GET'])
def chart():

    if f'{app_name}' in session and 'username' in session[f'{app_name}']:
        username = session[f'{app_name}']['username']
    else:
        return Response('用户未登录', 401)

    days = -1
    try:
        days = int(request.args.get('days')) - 1
    except Exception as ex:
        pass
    if days <= 0 or days >= 3650:
        days = 3650

    db_conn_str = f'mysql+pymysql://{db_username}:{db_password}@{db_url}/{db_name}'
    db_conn = create_engine(db_conn_str)

    sql = text('''
    SELECT `record_time`, `value`, `remark`
    FROM `weights`
    WHERE `username` = :username AND
          (`record_time` >= (DATE(NOW()) - INTERVAL :days DAY))
    ORDER BY `record_time` DESC
    ''')
    df = pd.read_sql(sql, con=db_conn,
                     params={'username': username, 'days': days})

    df.sort_values('record_time', inplace=True)
    span =  int(df.shape[0] / 5)
    if span < 1:
        span = 1
    df.loc[:,'value_ema'] = df['value'].ewm(span=span, adjust=False).mean().round(2)

    readings_string = ['', '']
    times_string = ''
    remark_string = ''
    for index, row in df.iterrows():
        readings_string[0] += str(row['value']) + ','
        readings_string[1] += str(row['value_ema']) + ','
        times_string += '"' + str(row['record_time']) + '",'
        remark_string += '"' + str(row['remark']) + '",'
    readings_string[0] = readings_string[0][:-1]
    readings_string[1] = readings_string[1][:-1]
    times_string = times_string[:-1]
    remark_string = remark_string[:-1]

    return render_template('chart.html',
                           times_string=times_string,
                           readings_strings=readings_string,
                           remark_string=remark_string)

@app.route('/prediction/', methods=['GET'])
def prediction():

    if f'{app_name}' in session and 'username' in session[f'{app_name}']:
        username = session[f'{app_name}']['username']
    else:
        return Response('用户未登录', 401)

    days = -1
    try:
        days = int(request.args.get('days')) - 1
    except Exception as ex:
        pass
    if days <= 0 or days >= 3650:
        days = 3650

    db_conn = create_engine(
            f'mysql+pymysql://{db_username}:{db_password}@{db_url}/{db_name}')

    sql = text('''
    SELECT `record_time`, `value`
    FROM `weights`
    WHERE `username` = :username AND
          (`record_time` >= (DATE(NOW()) - INTERVAL :days DAY))
    ORDER BY `record_time` DESC
    ''')
    df = pd.read_sql(sql=sql, con=db_conn, index_col='record_time',
                     params={'username': username, 'days': days})
    df.sort_values(by=['record_time'], ascending=[True], inplace=True)

    if df.shape[0] < 5:
        return '数据量太小，无预测结果'

    df['linear'] = df['value'] / df['value'].shift(1) - 1

    std = df['linear'].std()
    weighted_average = (df['value'].iloc[-1] * 0.6 +
                        df['value'].iloc[-2] * 0.3 +
                        df['value'].iloc[-3] * 0.1)
    predict = weighted_average * (1 + df['linear'].mean())
    predict_lower = weighted_average * (1 + df['linear'].mean() - 2 * std)
    predict_upper = weighted_average * (1 + df['linear'].mean() + 2 * std)

    return  (f'<b>{predict:.1f} KG</b>，'
             f'95%置信区间：[{predict_lower:.1f}, {predict_upper:.1f}]')


@app.route('/statistics/', methods=['GET'])
def statistics():

    if f'{app_name}' in session and 'username' in session[f'{app_name}']:
        username = session[f'{app_name}']['username']
    else:
        return Response('用户未登录', 401)

    days = -1
    try:
        days = int(request.args.get('days')) - 1
    except Exception as ex:
        days = 3650
    if days <= 0 or days >= 3650:
        days = 3650

    db_conn = create_engine(
            f'mysql+pymysql://{db_username}:{db_password}@{db_url}/{db_name}')

    sql = text('''
    SELECT `record_time`, `value`
    FROM `weights`
    WHERE `username` = :username AND
          (`record_time` >= (DATE(NOW()) - INTERVAL :days DAY))
    ORDER BY `record_time` DESC
    ''')
    df = pd.read_sql(sql=sql, con=db_conn, index_col='record_time',
                     params={'username': username, 'days': days})
    df.sort_values(by=['record_time'], ascending=[True], inplace=True)

    if df.shape[0] < 5:
        return '数据量太小，无法分析'

    df['linear'] = df['value'] / df['value'].shift(1) - 1
    df['log'] = np.log(df['value']) - np.log(df['value'].shift(1))
    df = df.iloc[1:]
    df['log_normal'] = (df['log'] - df['log'].mean())/df['log'].std()
   # print(df)

    matplotlib.use('WebAgg')
    fig1 = plt.figure(figsize=(5.5, 4))

    plt.title('折线图/Line Chart')
    plt.xlabel('时间/Time')
    plt.ylabel('标准化体重变动的对数/Standardized Log Weight Change')

    fig1.autofmt_xdate()
    # make space for and rotate the x-axis tick labels
    plt.hlines(y=df['log_normal'].mean(),
               xmin=df.index.values[0], xmax=df.index.values[df.shape[0]-1],
               color='r', linewidth=1, label='平均值/Mean')
    plt.hlines(y=df['log_normal'].mean() - 2 * df['log_normal'].std(),
               xmin=df.index.values[0], xmax=df.index.values[df.shape[0]-1],
               color='g', linewidth=1, label='两倍标准差/Two Standard Deviations')
    plt.hlines(y=df['log_normal'].mean() + 2 * df['log_normal'].std(),
               xmin=df.index.values[0], xmax=df.index.values[df.shape[0]-1],
               color='g', linewidth=1)
    plt.legend()
    plt.plot(df['log_normal'])

    fig2 = plt.figure(figsize=(5, 4))
    plt.title('直方图/Histogram')
    plt.xlabel('体重变动/Weight Change (标准化对数/Standardized Log)')
    plt.ylabel('概率密度/Probablity Density')
    _, bins, _ = plt.hist(df['log_normal'], bins=30, density=True)
    # You have to add density=True if want to overlay a normal distribution
    # curve over it.
    mu, sigma = norm.fit(df['log_normal'])
    y = stats.norm.pdf(bins, mu, sigma)
    plt.plot(bins, y, 'r--', linewidth=2,
             label='最佳拟合/Best Fitting')
    plt.legend()

    fig, ax = plt.subplots(figsize=(5, 4))
    fig3 = sm.qqplot(df['log_normal'], stats.norm, fit=True, line="45", ax=ax)
    plt.title('分位数-分位数图/Quantile-Quantile Plot')
    plt.xlabel('理论分位数/Theoretical Quantiles')
    plt.ylabel('样本分位数/Sample Quantiles')
    # https://stackoverflow.com/questions/49684811/display-matplotlib-graph-in-browser

    fig1_html = mpld3.fig_to_html(
        fig1, d3_url='https://monitor.sz.lan/resources/d3.v5.js',
        mpld3_url='https://monitor.sz.lan/resources/mpld3.v0.5.2.js',
        no_extras=True, template_type='general', use_http=False)

    fig2_html = mpld3.fig_to_html(
        fig2, d3_url='https://monitor.sz.lan/resources/d3.v5.js',
        mpld3_url='https://monitor.sz.lan/resources/mpld3.v0.5.2.js',
        no_extras=True, template_type='general', use_http=False)
    fig3_html = mpld3.fig_to_html(
        fig3, d3_url='https://monitor.sz.lan/resources/d3.v5.js',
        mpld3_url='https://monitor.sz.lan/resources/mpld3.v0.5.2.js',
        no_extras=True, template_type='general', use_http=False)

    try:
        p_adf = adfuller(df['log_normal'])[1]
    except Exception as ex:
        p_adf = 99
    _, p_shapiro = stats.shapiro(df['log_normal'])
    _, p_ks = stats.kstest(df['log_normal'], cdf='norm')
    test_html = f'Adfuller测试：p = {p_adf:.3f}'
    if p_adf > 0.05:
        test_html += '，大于0.05, 样本<b>不</b>是平稳随机过程'
    else:
        test_html += '，<b>不</b>大于0.05, 样本<b>是</b>平稳随机过程'
    test_html += f'<br>Shapiro测试：p = {p_shapiro:.3f}'
    if p_shapiro > 0.05:
        test_html += '，大于0.05, 样本服从正态分布'
    else:
        test_html += '，<b>不</b>大于0.05, 样本<b>不</b>服从正态分布'
    test_html += '<br>KS测试: p = {:.3f}'.format(p_ks)
    if p_ks > 0.05:
        test_html += '，大于0.05, 样本服从正态分布'
    else:
        test_html += '，<b>不</b>大于0.05, 样本<b>不</b>服从正态分布'

    # print(df['value'].iloc[-1], df['linear'].mean())

    return render_template('data-analysis.html', username=username,
                           fig1_html=fig1_html, fig2_html=fig2_html,
                           fig3_html=fig3_html,
                           test_html=test_html)


def cleanup(*args):

    global stop_signal
    stop_signal = True
    logging.info('Stop signal received, exiting')
    sys.exit(0)


def send_notification_email(delay: int, from_name: str, subject: str, mainbody: str):

    global stop_signal

    logging.info('Wait for {} seconds before sending the email'.format(delay))
    sec_count = 0
    while sec_count < delay:
        time.sleep(1)  # This delay has to be long enough to accommodate the startup time of pfSense.
        sec_count += 1
        if stop_signal:
            return
    logging.debug('Sending [{}] notification email'.format(subject))

    try:
        with open(settings_path, 'r') as json_file:
            json_str = json_file.read()
            json_data = json.loads(json_str)
    except:
        json_data = None
        logging.error(sys.exc_info())

    sender = json_data['email']['address']
    password = json_data['email']['password']
    receivers = ['admin@mamsds.net']

    message = ('From: {} <{}>\n'
                'To: Mamsds Admin Account <admin@mamsds.net>\n'
                'Content-Type: text/html; charset="UTF-8"\n'
                'Subject: {}\n'
                '<meta http-equiv="Content-Type"  content="text/html charset=UTF-8" /><html><font size="2" color="black">{}</font></html>'.format(from_name, sender, subject, mainbody.replace('\n', '<br>')))

    try:
        smtpObj = smtplib.SMTP(host='server172.web-hosting.com', port=587)
        smtpObj.starttls()
        smtpObj.login(sender, password)
        smtpObj.sendmail(sender, receivers, message.encode('utf-8'))
        smtpObj.quit()
        logging.debug("Email [{}] sent successfully".format(subject))
    except:
        logging.error("{}".format(sys.exc_info()))


def main():

    ap = argparse.ArgumentParser()
    ap.add_argument('--debug', dest='debug', action='store_true')
    args = vars(ap.parse_args())
    debug_mode = args['debug']

    logging.basicConfig(
        filename='/var/log/mamsds/weight-manager.log',
        level=logging.DEBUG if debug_mode else logging.INFO,
        format='%(asctime)s.%(msecs)03d %(levelname)s %(module)s - %(funcName)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
    )
    logging.info('weight manager started')
    start_time = dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if debug_mode is True:
        print('Running in debug mode')
        logging.info('Running in debug mode')
    else:
        logging.info('Running in production mode')

    signal.signal(signal.SIGINT, cleanup)
    signal.signal(signal.SIGTERM, cleanup)
    email_sender = threading.Thread(target=send_notification_email,
                                    args=(0 if debug_mode else 600, 'weight manager notification service', 'weight manager started', f'weight manager is started at {start_time}'))
    email_sender.start()
    logging.info('weight manager server')

    serve(app, host='0.0.0.0', port=90)


if __name__ == '__main__':

    main()
